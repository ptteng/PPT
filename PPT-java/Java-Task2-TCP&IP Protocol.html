<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>葡萄藤PPT</title>

    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/reveal.css">

    <!-- PPT主题，可以在/css/reveal/theme/中选择其他主题，目前暂时只能使用该模板 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/css/reveal/theme/ptt.css">

    <!-- syntax highlighting 代码高亮主题 -->
    <link rel="stylesheet" href="https://ptteng.github.io/PPT/lib/reveal/css/zenburn.css">

    <!-- 打印和PDF输出样式 -->
    <script>
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match( /print-pdf/gi ) ? 'https://ptteng.github.io/PPT/css/reveal/print/pdf.css' : '../css/reveal/print/paper.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
</head>
<body>
<img src="https://ptteng.github.io/PPT/img/demo/logo.png" alt="" usemap="#pttmap" class="base-logo">
<map name="pttmap">
    <area shape="rect" coords="0,0,276,58" href="http://www.jnshu.com" alt="" target="_blank"/>
</map>
<div class="reveal">
    <div class="slides">
        <section>
            <h4>什么是tcp/ip协议？TCP的三次握手指的是什么，为什么一定要三次握手，而不是四次或者是两次？</h4>
               <p>分享人:吴磊建</p>
        </section>
        <section>
            <p>1.背景介绍</p>
            <p>2.知识剖析</p>
            <p>3.常见问题</p>
            <p>4.解决方案</p>
            <p>5.编码实战</p>
            <p>6.扩展思考</p>
            <p>7.参考文献</p>
            <p>8.更多讨论</p>
        </section>
        <section>
            <h3>1.背景介绍</h3>
        </section>
 
        
        <section>
            <p>网络上的计算机在相互通信的过程中必须遵守统一的规则，否则通信将无法进行，这些规则我们称之计算机协议，</p>
            <p></P>
          </section>
		<section>
            <h3>2.知识剖析</h3>
        </section>

		
		<section>
                <p></p>
		    <p>TCP/IP协议是什么？</p>
		    <p>TCP/IP(Transmission Control Protocol/Internet Protocol)传输控制协议/互联网协议 </p>
			 <p>TCP/IP也称"国际协议簇"， 即不仅指 TCP/IP协议本身，而且包括与其有关的协议。 </P>
		    <p>作为开放系统互联协议中最早的协议之一，它为连接不同操作系统和不同硬件体系结构的互联网络提供通信支持，是一种网络通用语言。</p>
		
		 </section>
         <section>
            <p>干什么用？</p>
			<p>TCP/IP协议定义了在互联网络中如何传递、管理信息(文件传送、收发电子邮件、远程登录等)，并制定了在出错时必须遵循的规则。</p>
            <p>采用TCP/IP协议通过互联网传送信息可减少网络中的传输阻塞，方便大批量的数据在网上传输，从而提高网络的传输效率。</P>
         </section>
		
		<section>
		   <p>  IP协议（Internet Protocol）</p>
	       <p>协议的英文名直译就是：因特网协议,也就是为计算机网络相互连接进行通信而设计的协议。</p>
		   <p>在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。
   任何厂家生产的计算机系统，只要遵守IP协议就可以与因特网互连互通。
   正是因为有了IP协议，因特网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP协议也可以叫做“因特网协议”。</p>
	    </section>
	
 
	     <section>
			<p>  TCP协议(Transmission Control Protocol)</p>
			<p>在IP协议中定义的传输是单向的，也就是说发出去的货物对方有没有收到我们是不知道的。
			就好像8毛钱一份的平信一样。那对于重要的信件我们要寄挂号信怎么办呢？
			TCP协议就是帮我们寄“挂号信”的。TCP协议提供了可靠的面向对象的数据流传输服务的规则和约定。
			简单的说在TCP模式中，对方发一个数据包给你，你要发一个确认数据包给对方。通过这种确认来提供可靠性。</p>
                        
        </section>
	    <section>
			<p>TCP/IP协议分层结构（分5层）</p>
			<p>应用层</p>
            <p>应用层是我们经常接触使用的部分，比如常用的http协议、ftp协议（文件传输协议）、snmp（网络管理协议）、telnet （远程登录协议 ）、smtp（简单邮件传输协议）、dns（域名解析），
						</p>
                       
        </section>
        <section>
            <p>传输层</p>
            <p>传输层的作用就是将应用层的数据进行传输转运。比如我们常说的tcp（可靠的传输控制协议）、udp（用户数据报协议）。传输单位为报文段。</p>
            <p>tcp（Transmission Control Protocol）</p>
            <p>面向连接（先要和对方确定连接、传输结束需要断开连接，类似打电话）、复杂可靠的、有很好的重传和查错机制。一般用与高速、可靠的通信服务</p>
            <p>udp（user datagram protocol）</p>
            <p>面向无连接（无需确认对方是否存在，类似寄包裹）、简单高效、没有重传机制。一般用于即时通讯、广播通信等</p>
        </section>
	<section>
	<p>网络层</p>
	<p>网络层用来处理网络中流动的数据包，数据包为最小的传递单位，比如我们常用的ip协议、icmp协议、arp协议（通过分析ip地址得出物理mac地址）。</p>
	</section>
	
	
	<section>
	<p>数据链路层</p>
	<p>数据链路层一般用来处理连接硬件的部分，包括控制网卡、硬件相关的设备驱动等。传输单位数据帧。</p>
	<p>物理层</p>
	<p>物理层一般为负责数据传输的硬件，比如我们了解的双绞线电缆、无线、光纤等。比特流光电等信号发送接收数据。</p>
	</section>
	
	
	<section>
            <h3>3.常见问题</h3>
	</section>
        </section>
       		
	<section>
		<p>TCP三次握手的过程？</p>
                <p>为什么需要三次握手，而不是两次或四次握手？</p>
		<p></p>
	</section>

				
        <section>
            <h3>4.解决方案</h3>
			</section>
			<section>
			<p>TCP三次握手的过程？</p>
		<p>TCP是一个面向连接的服务,面向连接的服务是电话系统服务模式的抽象,
		每一次完整的数据传输都必须经过建立连接,数据传输和终止连接3个过程,TCP建立连接的过程称为三次握手</p>
		</section>
		<section>
		<p>三次握手：</p>
		<p>第一次：A “喂，你听得到吗？”（A发出请求）</p>
		<p>第二次：B “我听得到呀，你听得到我吗？”（B收到请求并作出回应）</p>
		<p>第三次：A “我能听到你，今天balabala…”（ A收到回应，开始向B发送信息）</p>
	</section>
        <section>
                <p>为什么需要三次握手，而不是两次或四次握手？</p>
                <p>两次握手</p>
  <p>A（客户端）发送了一个请求，等待B（服务端）的回应。
B收到请求，知道A的发信机正常，自己的收信机正常。按照两次握手的协定，B（不管A的状态）理所当然认为连接已经成功地建立了，便给A发送数据分组。</p>
  <p>可是，当B的应答分组在传输给A的途中丢失的话，A将不知道B是否已准备好，不知道B建议什么样的序列号，A甚至怀疑B是否收到自己的连接请求分组。
  在这种情况下，A认为连接还未建立成功，将忽略B发来的任何数据分组，只等待连接确认应答分组。</p>

        </section>
		<section>
		<p>后果</p>
		<p>而B在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
			<p>B会对已建立的连接保存必要的资源，如果大量的这种情况，B会崩溃。</p>
			<p>死锁：当某一进程提出资源的使用要求后，使得系统中一些进程处于无休止的阻塞状态，在无外力的作用下，这些进程永远也不能继续前进。我们称这种现象为死锁。</p>
			
			</section>
        
        <section>
                <p> TCP的三次握手最主要是防止已过期的连接再次传到被连接的主机。</p>
  <p>主机 A 发出的连接请求没有收到主机 B 的确认，于是经过一段时间后，主机 A 又重新向主机 B 发送连接请求，且建立成功，顺利完成数据传输。</p>
<p>考虑这样一种特殊情况，主机 A 第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机 B ，主机 B 以为是主机 A 又发起的新连接，
于是主机 B 同意连接，并向主机 A 发回确认，但是此时主机 A 根本不会理会，主机 B 就一直在等待主机 A 发送数据，导致主机 B 的资源浪费</p>

        </section>
		<section>
            <p>怎么确定第三次握手B就可以收到呢？</p>
			</section>
			<section>
  <p>答案是根本没法确定，因为完全可靠的通信协议是根本不存在的，我们任何的通信协议都是在接受这样的现实情况之上进行的。 
而三次握手后，A和B至少可以确认之前的通信情况，但无法确认之后的情况。 
在这个道理上说，无论是四次还是五次或是更多次都是徒劳的。</p>
        </section>
	
		
        <section>
            <h3>5.编码实战</h3>
        </section>

        <section>
        	<h3>6.扩展思考</h3>	
			</section>
			
		<section>
		<p>四次挥手</p>
		<p>第一次：A “我挂电话啦”(A进入FIN_WAIT_1)</p>
		<p>第二次：B "收到"（B进入CLOSE_WAIT，A收到回应进入FIN_WAIT_2）</p>
		<p>第三次：B “挂了吧”（B进入LAST_ACK，A收到信息进入TIME_WAIT）</p>
		<p>第四次：A “好”（B收到A的ACK报文段以后，就关闭连接；
		此时，A等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，A也可以关闭连接了。）</p>
        </section>
		<section>
		<p>第四次挥手，为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？</p>
<p>若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。
我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。  </p>
		</section>
        
        <section>
            <h3>7.参考文献</h3>
            <p>https://www.cnblogs.com/leezhxing/p/4524176.html</p>
			<p>http://blog.csdn.net/to_be_better/article/details/54885684</p>
			<p><p>

        </section>
        <section>
            <h3>8.更多讨论</h3>
			<p>TCP/IP协议基于什么？与ISO的区别</p>
            1. 首先TCP/IP他是一个协议簇；而OSI（开放系统互联）则是一个模型，且TCP/IP的开发时间在OSI之前。
2. TCP/IP是由一些交互性的模块做成的分层次的协议，其中每个模块提供特定的功能；OSi则指定了哪个功能是属于哪一层的。
3. TCP/IP是五层结构，而OSI是七层结构。OSI的最高三层在TCP中用应用层表示。
        </section>
		
		

    </div>
</div>

<script src="https://ptteng.github.io/PPT/lib/reveal/js/head.min.js"></script>
<script src="https://ptteng.github.io/PPT/lib/reveal/reveal.js"></script>

<script>
    // 以下为常见配置属性的默认值
    // {
    //  controls: true, // 是否在右下角展示控制条
    //  progress: true, // 是否显示演示的进度条
    //  slideNumber: false, // 是否显示当前幻灯片的页数编号，也可以使用代码slideNumber: 'c / t' ，表示当前页/总页数。
    //  history: false, // 是否将每个幻灯片改变加入到浏览器的历史记录中去
    //  keyboard: true, // 是否启用键盘快捷键来导航
    //  overview: true, // 是否启用幻灯片的概览模式，可使用"Esc"或"o"键来切换概览模式
    //  center: true, // 是否将幻灯片垂直居中
    //  touch: true, // 是否在触屏设备上启用触摸滑动切换
    //  loop: false, // 是否循环演示
    //  rtl: false, // 是否将演示的方向变成RTL，即从右往左
    //  fragments: true, // 全局开启和关闭碎片。
    //  autoSlide: 0, // 两个幻灯片之间自动切换的时间间隔（毫秒），当设置成 0 的时候则禁止自动切换，该值可以被幻灯片上的 ` data-autoslide` 属性覆盖
    //  transition: 'default', // 切换过渡效果，有none/fade/slide/convex/concave/zoom
    //  transitionSpeed: 'default', // 过渡速度，default/fast/slow
    //  mouseWheel: true, //是否启用通过鼠标滚轮来切换幻灯片
    // }
    // 初始化幻灯片
    Reveal.initialize({
        history: true,
        dependencies: [
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/marked.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/markdown/markdown.js' },
            { src: 'https://ptteng.github.io/PPT/plugin/notes/notes.js', async: true },
            { src: 'https://ptteng.github.io/PPT/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
        ]
    });
</script>
</body>
</html>
